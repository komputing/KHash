package khash.sha256

import kotlinx.io.core.toByteArray
import kotlinx.serialization.internal.HexConverter.parseHexBinary
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class Sha256Tests {

    // HASHING

    @Test
    fun testDigest() {
        testHash("", "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
        testHash("Hello world!", "c0535e4be2b79ffd93291305436bf889314e4a3faec05ecffcbb7df31ad9e51a")

        val loremIpsum = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " +
            "Proin pulvinar turpis purus, sit amet dapibus magna commodo quis metus."
        testHash(loremIpsum, "60497604d2f6b4df42cea5efb8956f587f81a4ad66fa1b65d9e085224d255036")
    }

    private fun testHash(input: String, expected: String) {
        val inputArray = input.toByteArray()
        val expectedOutput = parseHexBinary(expected)
        assertTrue(expectedOutput.contentEquals(Sha256.digest(inputArray)))
    }

    @Test fun testHashRawBytes() {
        val b = ByteArray(256)
        for (i in b.indices) {
            b[i] = i.toByte()
        }

        val expected = parseHexBinary("40aff2e9d2d8922e47afd4648e6967497158785fbd1da870e7110266bf944880")
        assertTrue(expected.contentEquals(Sha256.digest(b)))
    }

    // PADDING

    @Test fun testPaddedLengthDivisibleBy512() {
        val b = byteArrayOf(0, 1, 2, 3, 0)
        val padded = Sha256.padMessage(b)
        val paddedLengthBits = padded.size * 8
        assertEquals(paddedLengthBits % 512, 0)
    }

    @Test fun testPaddedMessageHas1Bit() {
        val b = ByteArray(64)
        val padded = Sha256.padMessage(b)
        assertEquals(128.toByte(), padded[b.size])
    }

    @Test fun testPaddingAllZero() {
        val b = byteArrayOf(1, 1, 1, 1, 1, 1, 1)
        val padded = Sha256.padMessage(b)
        for (i in b.size + 1 until padded.size - 8) {
            assertEquals(0, padded[i].toInt(), "byte $i not 0")
        }
    }
}
